#!/usr/bin/env python3
# -----------------------------------------------------------------------------
# cace_makeplot.py
# -----------------------------------------------------------------------------
# Plot routines for CACE using matplotlib
# -----------------------------------------------------------------------------

import re
import os
import copy
import matplotlib

from matplotlib.figure import Figure

# Warning: PIL Tk required, may not be in default install of python3.
# For Fedora, for example, need "yum install python-pillow-tk"

from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from matplotlib.backends.backend_agg import FigureCanvasAgg

from .cace_gensim import twos_comp
from .cace_collate import addnewresult

# -----------------------------------------------------------------------------
# Given a plot record from a spec sheet and a full set of testbenches, generate
# a plot.  The name of the plot file and the vectors to plot, labels, legends,
# and so forth are all contained in the 'plotrec' dictionary.
#
# If run from a GUI then "parent" is a window passed by the caller that the
# plot will be drawn in.
#
# Returns the canvas record generated by matplotlib.
# -----------------------------------------------------------------------------


def cace_makeplot(dsheet, param, parent=None):

    if "plot" not in param:
        return None
    else:
        plotrec = param["plot"]

    if "variables" not in param:
        variables = []
    else:
        variables = param["variables"]

    if "runtime_options" in dsheet:
        runtime_options = dsheet["runtime_options"]
    else:
        runtime_options = None

    debug = False
    if runtime_options:
        if "noplot" in runtime_options:
            if runtime_options["noplot"]:
                return None
        if "debug" in runtime_options:
            debug = runtime_options["debug"]

    # Development:  For now, just take the results from the 1st testbench
    # All testbenches should have the same data, just with different sets
    # of conditions.  Multiple testbench data will be steps in the graph.

    numtbs = len(param["testbenches"])
    if numtbs == 0:
        print("Error:  Plot has no results.")

    tbzero = param["testbenches"][0]
    results = copy.deepcopy(tbzero["results"])

    binrex = re.compile(r"([0-9]*)\'([bodh])", re.IGNORECASE)
    # Organize data into plot lines according to formatting

    if "type" in plotrec:
        plottype = plotrec["type"]
    else:
        plottype = "xyplot"

    # The 'format' record of the 'simulate' dictionary in the parameter
    # indicates how the simulation data should be formatted.  The first
    # two items describe how to read the file and are discarded.  The
    # routine that reads the simulation data always moves the "result"
    # entry to the 1st position, so the format needs to be adjusted
    # accordingly.

    simdict = copy.deepcopy(param["simulate"])
    if "format" in simdict:
        simformat = simdict["format"][2:]
        if "result" in simformat:
            ridx = simformat.index("result")
            if ridx != 0:
                simformat.insert(0, simformat.pop(simformat.index("result")))
    else:
        simformat = ["result"]

    if plottype == "histogram":
        xname = "result"
    else:
        xname = plotrec["xaxis"]

    # In case results[] is not a vector. . .  This should have been handled
    # outside of cace_makeplot and probably needs to be fixed.

    if not isinstance(results[0], list):
        for i in range(len(results)):
            result = results[i]
            if not isinstance(result, list):
                results[i] = [result]

    # Find index of X data in results.  All results lines have the same
    # data, so pick up the number of items per result from the 1st entry.

    rlen = len(results[0])
    try:
        xidx = next(r for r in range(rlen) if simformat[r] == xname)
    except StopIteration:

        # x-axis variable is not in the variable list.  If it exists as
        # a testbench condition and varies over the testbenches, then
        # add a column to each row of results to represent the variable,
        # and add all testbench results to the <results> array.

        conditions = tbzero["conditions"]
        notfound = True
        for cond in conditions:
            if cond[0] == xname:
                condvalue = cond[2]
                notfound = False
                break

        if notfound:
            print("Plot error:  No signal " + xname + " recorded in format.")
            return None

        for result in results:
            result.append(condvalue)

        for tbi in param["testbenches"][1:]:
            conditions = tbi["conditions"]
            for cond in conditions:
                if cond[0] == xname:
                    condvalue = cond[2]
                    break
            for result in tbi["results"]:
                if isinstance(result, list):
                    newresult = result.copy()
                else:
                    newresult = [result]
                newresult.append(condvalue)
                results.append(newresult)

        rlen = len(results[0])
        xidx = rlen - 1
        simformat.append(xname)

    # Find unique values of each variable (except results, traces, and iterations)

    conditions = tbzero["conditions"]
    binconv = []

    if debug:
        print("Processing " + str(rlen) + " plot variables.")

    # Collect the records of everything being plotted.

    tracedicts = []
    traces = []
    residx = 0
    for i in range(0, rlen):
        if i != xidx:
            # Keep track of which indexes have traces (i.e., not the X axis values)
            traces.append(i)
        try:
            varrec = next(item for item in variables if item["name"] == simformat[i])
        except StopIteration:
            if simformat[i] == "result":
                varrec = {}
                varrec["name"] = "result"
                if "unit" in param:
                    varrec["unit"] = param["unit"]
                residx = i
            else:
                varrec = {}

        tracedicts.append(varrec)

        # Mark which items need converting from digital.  Format is verilog-like.  Use
        # a format width that is larger than the actual number of digits to force
        # unsigned conversion.

        if "name" in varrec:
            varname = varrec["name"]
        else:
            varname = conditions[i][0]

        bmatch = binrex.match(varname)
        if bmatch:
            digits = bmatch.group(1)
            if digits == "":
                digits = len(results[0][i])
            else:
                digits = int(digits)
            cbase = bmatch.group(2)
            if cbase == "b":
                base = 2
            elif cbase == "o":
                base = 8
            elif cbase == "d":
                base = 10
            else:
                base = 16
            binconv.append([base, digits])
        else:
            binconv.append([])

    # Which stepped variables (ignoring X axis variable) have more than one value?
    # watchsteps = list(i for i in range(1, rlen) if len(steps[i]) > 1 and i != xidx)
    watchsteps = []

    # Diagnostic
    # print("Stepped conditions are: ")
    # for j in watchsteps:
    #      print(results[0][j] + '  (' + str(len(steps[j])) + ' steps)')  # FIXME

    needconvert = False
    if xname.split("|")[0] == "digital" or binconv[xidx] != []:
        needconvert = True

    # Collect results.  Make a separate record for each unique set of stepped conditions
    # encountered.  Record has (X, Y) vector and a list of conditions.
    pdata = {}

    # Limit the amount of data being processed.  NOTE:  This is a stupid-simple
    # way to do it and it needs much better handling;  e.g., import scipy and
    # resample to a constant time step.

    numpoints = len(results)
    if debug:
        print("Processing " + str(numpoints) + " data points.")
    if numpoints > 1000:
        stepsize = int(numpoints / 1000)
        if debug:
            print("Truncating data with step size " + str(stepsize))
    else:
        stepsize = 1

    for idx in range(0, numpoints, stepsize):
        item = results[idx]

        if needconvert:
            base = binconv[xidx][0]
            digits = binconv[xidx][1]
            # Recast binary strings as integers
            # Watch for strings that have been cast to floats (need to find the source of this)
            if "." in item[xidx]:
                item[xidx] = item[xidx].split(".")[0]
            a = int(item[xidx], base)
            b = twos_comp(a, digits)
            xvalue = b
        else:
            xvalue = item[xidx]

        slist = []
        for j in watchsteps:
            slist.append(item[j])
        istr = ",".join(slist)
        if istr not in pdata:
            stextlist = []
            for j in watchsteps:
                if results[1][j] == "":
                    # FIXME:  results[0][x] is no longer the trace name
                    stextlist.append(results[0][j] + "=" + item[j])
                else:
                    # FIXME:  results[0][x] is no longer the trace name
                    stextlist.append(
                        results[0][j] + "=" + item[j] + " " + results[1][j]
                    )
            pdict = {}
            pdata[istr] = pdict
            pdict["xdata"] = []
            if stextlist:
                tracelegnd = False
            else:
                tracelegnd = True

            for i in traces:
                aname = "ydata" + str(i)
                pdict[aname] = []
                alabel = "ylabel" + str(i)

                # Get the name of the trace.
                tracedict = tracedicts[i]
                if "display" in tracedict:
                    tracename = tracedict["display"]
                else:
                    tracename = tracedict["name"]

                # Get the units of the trace
                if "unit" in tracedict:
                    if not binrex.match(tracedict["unit"]):
                        tracename += " (" + tracedict["unit"] + ")"

                pdict[alabel] = tracename

            pdict["sdata"] = " ".join(stextlist)
        else:
            pdict = pdata[istr]

        try:
            xfloat = float(xvalue)
        except:
            pdict["xdata"].append(xvalue)
        else:
            pdict["xdata"].append(xfloat)

        for i in traces:
            # For each trace, convert the value from digital to integer if needed
            if binconv[i] != []:
                base = binconv[i][0]
                digits = binconv[i][1]
                a = int(item[i], base)
                b = twos_comp(a, digits)
                yvalue = b
            else:
                yvalue = item[i]

            aname = "ydata" + str(i)
            try:
                yfloat = float(yvalue)
            except:
                pdict[aname].append(yvalue)
            else:
                pdict[aname].append(yfloat)

    fig = Figure()
    if parent == None:
        canvas = FigureCanvasAgg(fig)
    else:
        canvas = FigureCanvasTkAgg(fig, parent)

    # With no parent, just make one plot and put the legend off to the side.  The
    # 'extra artists' capability of print_figure will take care of the bounding box.
    # For display, prepare two subplots so that the legend takes up the space of the
    # second one.
    if parent == None:
        ax = fig.add_subplot(111)
    else:
        ax = fig.add_subplot(121)

    # fig.hold(True)
    for record in pdata:
        pdict = pdata[record]

        # Check if xdata is numeric
        try:
            test = float(pdict["xdata"][0])
        except ValueError:
            numeric = False
            xdata = [i for i in range(len(pdict["xdata"]))]
        else:
            numeric = True
            xdata = list(map(float, pdict["xdata"]))

        if plottype == "histogram":
            ax.hist(xdata, histtype="barstacked", label=pdict["sdata"], stacked=True)
        else:
            for i in traces:
                aname = "ydata" + str(i)
                alabl = "ylabel" + str(i)
                ax.plot(xdata, pdict[aname], label=pdict[alabl] + " " + pdict["sdata"])

        if not numeric:
            ax.set_xticks(xdata)
            ax.set_xticklabels(pdict["xdata"])

    # Automatically generate X axis label if not given alternate text

    tracerec = tracedicts[xidx]
    if "xlabel" in plotrec:
        xtext = plotrec["xlabel"]
    else:
        xtext = tracerec["name"]
    if "unit" in tracerec:
        xtext += " (" + tracerec["unit"] + ")"
    ax.set_xlabel(xtext)

    # Automatically generate Y axis label if not given alternate text

    tracerec = tracedicts[residx]
    if "ylabel" in plotrec:
        ytext = plotrec["ylabel"]
    else:
        ytext = tracerec["name"]
    if "unit" in tracerec:
        ytext += " (" + tracerec["unit"] + ")"
    ax.set_ylabel(ytext)

    ax.grid(True)
    if watchsteps or tracelegnd:
        legnd = ax.legend(loc=2, bbox_to_anchor=(1.05, 1), borderaxespad=0.0)
    else:
        legnd = None

    if legnd:
        legnd.set_draggable(True)

    if parent == None:
        paths = dsheet["paths"]
        if "plots" in paths:
            plotdir = paths["plots"]
        else:
            plotdir = paths["simulation"]

        netlist_source = runtime_options["netlist_source"]

        if "filename" in plotrec:
            plotname = plotrec["filename"]
        else:
            plotname = param["name"] + ".png"

        filepath = os.path.join(plotdir, netlist_source)
        if not os.path.isdir(filepath):
            os.makedirs(filepath)

        filename = os.path.join(plotdir, netlist_source, plotname)

        # NOTE: print_figure only makes use of bbox_extra_artists if
        # bbox_inches is set to 'tight'.  This forces a two-pass method
        # that calculates the real maximum bounds of the figure.  Otherwise
        # the legend gets clipped.
        if legnd:
            canvas.print_figure(
                filename, bbox_inches="tight", bbox_extra_artists=[legnd]
            )
        else:
            canvas.print_figure(filename, bbox_inches="tight")

    resultdict = {}
    resultdict["status"] = "done"
    resultdict["name"] = runtime_options["netlist_source"]
    addnewresult(param, resultdict)

    return canvas
