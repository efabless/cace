#!/usr/bin/env python3
# -----------------------------------------------------------------------------
# cace_makeplot.py
# -----------------------------------------------------------------------------
# Plot routines for CACE using matplotlib
# -----------------------------------------------------------------------------

import re
import os
import copy
import matplotlib

from matplotlib.figure import Figure

# Warning: PIL Tk required, may not be in default install of python3.
# For Fedora, for example, need "yum install python-pillow-tk"

from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from matplotlib.backends.backend_agg import FigureCanvasAgg

from .cace_gensim import twos_comp
from .cace_collate import addnewresult

# -----------------------------------------------------------------------------
# Given a plot record from a spec sheet and a full set of testbenches, generate
# a plot.  The name of the plot file and the vectors to plot, labels, legends,
# and so forth are all contained in the 'plotrec' dictionary.
#
# If run from a GUI then "parent" is a window passed by the caller that the
# plot will be drawn in.
#
# Returns the canvas record generated by matplotlib.
# -----------------------------------------------------------------------------


def cace_makeplot(dsheet, param, parent=None):

    if 'plot' not in param:
        return None
    else:
        plotrec = param['plot']

    if 'variables' not in param:
        variables = []
    else:
        variables = param['variables']

    if 'runtime_options' in dsheet:
        runtime_options = dsheet['runtime_options']
    else:
        runtime_options = None

    debug = False
    if runtime_options:
        if 'noplot' in runtime_options:
            if runtime_options['noplot']:
                return None
        if 'debug' in runtime_options:
            debug = runtime_options['debug']

    # Development:  For now, just take the results from the 1st testbench
    # All testbenches should have the same data, just with different sets
    # of conditions.  Multiple testbench data will be steps in the graph.

    numtbs = len(param['testbenches'])
    if numtbs == 0:
        print('Error:  Plot has no results.')

    tbzero = param['testbenches'][0]
    results = copy.deepcopy(tbzero['results'])

    binrex = re.compile(r'([0-9]*)\'([bodh])', re.IGNORECASE)
    # Organize data into plot lines according to formatting

    if 'type' in plotrec:
        plottype = plotrec['type']
    else:
        plottype = 'xyplot'

    # The 'format' record of the 'simulate' dictionary in the parameter
    # indicates how the simulation data should be formatted.  The first
    # two items describe how to read the file and are discarded.  The
    # routine that reads the simulation data always moves the "result"
    # entry to the 1st position, so the format needs to be adjusted
    # accordingly.

    simdict = copy.deepcopy(param['simulate'])
    if 'format' in simdict:
        simformat = simdict['format'][2:]
        if 'result' in simformat:
            ridx = simformat.index('result')
            if ridx != 0:
                simformat.insert(0, simformat.pop(simformat.index('result')))
    else:
        simformat = ['result']

    if plottype == 'histogram':
        xname = 'result'
    else:
        xname = plotrec['xaxis']

    # In case results[] is not a vector. . .  This should have been handled
    # outside of cace_makeplot and probably needs to be fixed.

    if not isinstance(results[0], list):
        for i in range(len(results)):
            result = results[i]
            if not isinstance(result, list):
                results[i] = [result]

    # Find index of X data in results.  All results lines have the same
    # data, so pick up the number of items per result from the 1st entry.

    rlen = len(results[0])
    try:
        xidx = next(r for r in range(rlen) if simformat[r] == xname)
    except StopIteration:

        # x-axis variable is not in the variable list.  If it exists as
        # a testbench condition and varies over the testbenches, then
        # add a column to each row of results to represent the variable,
        # and add all testbench results to the <results> array.

        conditions = tbzero['conditions']
        notfound = True
        for cond in conditions:
            if cond[0] == xname:
                condvalue = cond[2]
                notfound = False
                break

        if notfound:
            print('Plot error:  No signal ' + xname + ' recorded in format.')
            return None

        for result in results:
            result.append(condvalue)

        for tbi in param['testbenches'][1:]:
            conditions = tbi['conditions']
            for cond in conditions:
                if cond[0] == xname:
                    condvalue = cond[2]
                    break
            for result in tbi['results']:
                if isinstance(result, list):
                    newresult = result.copy()
                else:
                    newresult = [result]
                newresult.append(condvalue)
                results.append(newresult)

        rlen = len(results[0])
        xidx = rlen - 1
        simformat.append(xname)

    # Find unique values of each variable (except results, traces, and iterations)

    conditions = tbzero['conditions']
    binconv = []

    if debug:
        print('Processing ' + str(rlen) + ' plot variables.')

    # Collect the records of everything being plotted.

    tracedicts = []
    traces = []
    residx = 0
    for i in range(0, rlen):
        if i != xidx:
            # Keep track of which indexes have traces (i.e., not the X axis values)
            traces.append(i)
        try:
            varrec = next(
                item for item in variables if item['name'] == simformat[i]
            )
        except StopIteration:
            if simformat[i] == 'result':
                varrec = {}
                varrec['name'] = 'result'
                if 'unit' in param:
                    varrec['unit'] = param['unit']
                residx = i
            else:
                varrec = {}

        tracedicts.append(varrec)

        # Mark which items need converting from digital.  Format is verilog-like.  Use
        # a format width that is larger than the actual number of digits to force
        # unsigned conversion.

        if 'name' in varrec:
            varname = varrec['name']
        else:
            varname = conditions[i][0]

        bmatch = binrex.match(varname)
        if bmatch:
            digits = bmatch.group(1)
            if digits == '':
                digits = len(results[0][i])
            else:
                digits = int(digits)
            cbase = bmatch.group(2)
            if cbase == 'b':
                base = 2
            elif cbase == 'o':
                base = 8
            elif cbase == 'd':
                base = 10
            else:
                base = 16
            binconv.append([base, digits])
        else:
            binconv.append([])

    # Which stepped variables (ignoring X axis variable) have more than one value?
    # watchsteps = list(i for i in range(1, rlen) if len(steps[i]) > 1 and i != xidx)
    watchsteps = []

    # Diagnostic
    # print("Stepped conditions are: ")
    # for j in watchsteps:
    #      print(results[0][j] + '  (' + str(len(steps[j])) + ' steps)')  # FIXME

    needconvert = False
    if xname.split('|')[0] == 'digital' or binconv[xidx] != []:
        needconvert = True

    # Collect results.  Make a separate record for each unique set of stepped conditions
    # encountered.  Record has (X, Y) vector and a list of conditions.
    pdata = {}

    # Limit the amount of data being processed.  NOTE:  This is a stupid-simple
    # way to do it and it needs much better handling;  e.g., import scipy and
    # resample to a constant time step.

    numpoints = len(results)
    if debug:
        print('Processing ' + str(numpoints) + ' data points.')
    if numpoints > 1000:
        stepsize = int(numpoints / 1000)
        if debug:
            print('Truncating data with step size ' + str(stepsize))
    else:
        stepsize = 1

    for idx in range(0, numpoints, stepsize):
        item = results[idx]

        if needconvert:
            base = binconv[xidx][0]
            digits = binconv[xidx][1]
            # Recast binary strings as integers
            # Watch for strings that have been cast to floats (need to find the source of this)
            if '.' in item[xidx]:
                item[xidx] = item[xidx].split('.')[0]
            a = int(item[xidx], base)
            b = twos_comp(a, digits)
            xvalue = b
        else:
            xvalue = item[xidx]

        slist = []
        for j in watchsteps:
            slist.append(item[j])
        istr = ','.join(slist)
        if istr not in pdata:
            stextlist = []
            for j in watchsteps:
                if results[1][j] == '':
                    # FIXME:  results[0][x] is no longer the trace name
                    stextlist.append(results[0][j] + '=' + item[j])
                else:
                    # FIXME:  results[0][x] is no longer the trace name
                    stextlist.append(
                        results[0][j] + '=' + item[j] + ' ' + results[1][j]
                    )
            pdict = {}
            pdata[istr] = pdict
            pdict['xdata'] = []
            if stextlist:
                tracelegnd = False
            else:
                tracelegnd = True

            for i in traces:
                aname = 'ydata' + str(i)
                pdict[aname] = []
                alabel = 'ylabel' + str(i)

                # Get the name of the trace.
                tracedict = tracedicts[i]
                if 'display' in tracedict:
                    tracename = tracedict['display']
                else:
                    tracename = tracedict['name']

                # Get the units of the trace
                if 'unit' in tracedict:
                    if not binrex.match(tracedict['unit']):
                        tracename += ' (' + tracedict['unit'] + ')'

                pdict[alabel] = tracename

            pdict['sdata'] = ' '.join(stextlist)
        else:
            pdict = pdata[istr]

        try:
            xfloat = float(xvalue)
        except:
            pdict['xdata'].append(xvalue)
        else:
            pdict['xdata'].append(xfloat)

        for i in traces:
            # For each trace, convert the value from digital to integer if needed
            if binconv[i] != []:
                base = binconv[i][0]
                digits = binconv[i][1]
                a = int(item[i], base)
                b = twos_comp(a, digits)
                yvalue = b
            else:
                yvalue = item[i]

            aname = 'ydata' + str(i)
            try:
                yfloat = float(yvalue)
            except:
                pdict[aname].append(yvalue)
            else:
                pdict[aname].append(yfloat)

    fig = Figure()
    if parent == None:
        canvas = FigureCanvasAgg(fig)
    else:
        canvas = FigureCanvasTkAgg(fig, parent)

    # With no parent, just make one plot and put the legend off to the side.  The
    # 'extra artists' capability of print_figure will take care of the bounding box.
    # For display, prepare two subplots so that the legend takes up the space of the
    # second one.
    if parent == None:
        ax = fig.add_subplot(111)
    else:
        ax = fig.add_subplot(121)

    # fig.hold(True)
    for record in pdata:
        pdict = pdata[record]

        # Check if xdata is numeric
        try:
            test = float(pdict['xdata'][0])
        except ValueError:
            numeric = False
            xdata = [i for i in range(len(pdict['xdata']))]
        else:
            numeric = True
            xdata = list(map(float, pdict['xdata']))

        if plottype == 'histogram':
            ax.hist(
                xdata,
                histtype='barstacked',
                label=pdict['sdata'],
                stacked=True,
            )
        else:
            for i in traces:
                aname = 'ydata' + str(i)
                alabl = 'ylabel' + str(i)
                ax.plot(
                    xdata,
                    pdict[aname],
                    label=pdict[alabl] + ' ' + pdict['sdata'],
                )

        if not numeric:
            ax.set_xticks(xdata)
            ax.set_xticklabels(pdict['xdata'])

    # Automatically generate X axis label if not given alternate text

    tracerec = tracedicts[xidx]
    if 'xlabel' in plotrec:
        xtext = plotrec['xlabel']
    else:
        xtext = tracerec['name']
    if 'unit' in tracerec:
        xtext += ' (' + tracerec['unit'] + ')'
    ax.set_xlabel(xtext)

    # Automatically generate Y axis label if not given alternate text

    tracerec = tracedicts[residx]
    if 'ylabel' in plotrec:
        ytext = plotrec['ylabel']
    else:
        ytext = tracerec['name']
    if 'unit' in tracerec:
        ytext += ' (' + tracerec['unit'] + ')'
    ax.set_ylabel(ytext)

    ax.grid(True)
    if watchsteps or tracelegnd:
        legnd = ax.legend(loc=2, bbox_to_anchor=(1.05, 1), borderaxespad=0.0)
    else:
        legnd = None

    if legnd:
        legnd.set_draggable(True)

    if parent == None:
        paths = dsheet['paths']
        if 'plots' in paths:
            plotdir = paths['plots']
        else:
            plotdir = paths['simulation']

        netlist_source = runtime_options['netlist_source']

        if 'filename' in plotrec:
            plotname = plotrec['filename']
        else:
            plotname = param['name'] + '.png'

        filepath = os.path.join(plotdir, netlist_source)
        if not os.path.isdir(filepath):
            os.makedirs(filepath)

        filename = os.path.join(plotdir, netlist_source, plotname)

        # NOTE: print_figure only makes use of bbox_extra_artists if
        # bbox_inches is set to 'tight'.  This forces a two-pass method
        # that calculates the real maximum bounds of the figure.  Otherwise
        # the legend gets clipped.
        if legnd:
            canvas.print_figure(
                filename, bbox_inches='tight', bbox_extra_artists=[legnd]
            )
        else:
            canvas.print_figure(filename, bbox_inches='tight')

    resultdict = {}
    resultdict['status'] = 'done'
    resultdict['name'] = runtime_options['netlist_source']
    addnewresult(param, resultdict)

    return canvas
